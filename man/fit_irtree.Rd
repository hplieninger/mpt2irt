% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fit_model.R
\name{fit_irtree}
\alias{fit_irtree}
\title{Fit an mpt2irt model.}
\usage{
fit_irtree(X, revItem = NULL, traitItem = rep(1, ncol(X)), df = NULL,
  V = NULL, fitModel = c("ext", "2012", "pcm", "steps", "shift", "ext2"),
  model = NULL, fitMethod = c("stan", "jags"), outFormat = NULL,
  startSmall = FALSE, M = 1000, warmup = 1000, n.chains = 2, thin = 1,
  method = "parallel", add2varlist = NULL, cores = NULL,
  summarise = FALSE, N2 = 2, ...)
}
\arguments{
\item{X}{an N x J matrix of observed responses for categories 1...5 (use
\code{\link{mult_to_cat}} to transform a multinomial frequency matrix with 1s/0s to
responses from 1...5)}

\item{revItem}{vector of length J specifying reversed items (1=reversed,
0=not reversed)}

\item{traitItem}{vector of length J specifying the underlying traits (e.g.,
indexed from 1...5). Standard: only a single trait is measured by all
items. If the Big5 are measures, might be something like
c(1,1,1,2,2,2,...,5,5,5,5)}

\item{df}{degrees of freedom for wishart prior on covariance of traits
(standard/minimum: number of processes + 1)}

\item{V}{prior for wishart distribution (standard: diagonal matrix)}

\item{fitModel}{Character. Either \code{"2012"} (Boeckenholt Model without 
acquiescence), or \code{"ext"} (Acquiescence Model), or \code{"pcm"}
(partial credit model), or \code{"steps"} (Steps Model [Verhelst; Tutz]),
or \code{"shift"} (shift model, i.e., \code{"2012"} +  ars-shift).}

\item{model}{If \code{NULL} (the usual case), this is determined by
\code{fitModel}. Otherwise, this is passed to \code{\link[rstan]{sampling}}
(for Stan) or \code{\link[runjags]{run.jags}} (for JAGS).}

\item{fitMethod}{whether to use JAGS or Stan}

\item{outFormat}{either "mcmc.list" (can be analyzed with coda package) or
"stan" or "runjags"}

\item{startSmall}{Whether to use random starting values for
beta sampled from "wide" (startSmall=F, generated within JAGS) or "narrow"
priors (startSmall=T; beta and theta closer to 0; might solve problems with
slow convergence of some chains for extreme starting values).}

\item{M}{number of MCMC samples (after warmup)}

\item{warmup}{number of samples for warmup (in JAGS: 1/5 for adaption, 4/5
for burnin)}

\item{n.chains}{number of MCMC chains (and number of CPUs used)}

\item{thin}{thinning of MCMC samples}

\item{method}{the method with which to call JAGS; probably a character vector specifying one of 'rjags', 'simple', 'interruptible', 'parallel', 'rjparallel', 'background', 'bgparallel' or 'snow'. The 'rjags' and 'rjparallel' methods run JAGS using the rjags package, whereas other options do not require the rjags package and call JAGS as an external executable.  The advantage of the 'rjags' method is that the model will not need to be recompiled between successive calls to extend.jags, all other methods require a re-compilation (and adaptation if necessary) step at every call to extend.jags.  Note that the 'rjparallel' and 'snow' methods may leave behind zombie JAGS processes if the user interrupts the R session used to start the simulations - for this reason the 'parallel' method is recommended for interactive use with parallel chains. The 'background' and 'bgparallel' return a filename for the started simulation, which can be read using \code{\link{results.jags}}.  The 'parallel' and 'interruptible' methods for Windows require XP Professional, Vista or later (or any Unix-alike).  For more information refer to the userguide vignette.}

\item{add2varlist}{Additional variables to monitor (e.g., \code{c("deviance",
"pd", "popt", "dic")} for JAGS)}

\item{cores}{Number of cores to use when executing the chains in parallel,
    which defaults to 1 but we recommend setting the \code{mc.cores} option 
    to be as many processors as the hardware and RAM allow (up to the 
    number of chains).}

\item{summarise}{should summary statistics be automatically calculated for the output chains?  Default TRUE (but see also ?runjags.options -> force.summary).}

\item{N2}{Numeric. Number of persons for whom to draw posterior predictives.
Specify equal to \code{nrow(X)} in order to draw values for all persons.
This is mainly implemented for efficiency reasons in order to avoid
massivly drawing samples which the user is not interested in.}

\item{...}{further arguments passed to \code{\link[rstan]{sampling}} (for Stan) or \code{\link[runjags]{run.jags}} (for JAGS)
working directory ("_Stanprogress.txt")}
}
\value{
Returns a list where the output form either JAGS or Stan is stored in the entry \code{samples}.
}
\description{
This function fits an mpt2irt model. Either the so-called Boeckenholt Model
can be fit (\code{fitModel = "2012"}) that assumes the three processes MRS,
ERS, and target trait; or the so-called Acquiescence Model can be fit that
additionally takes ARS into account (\code{fitModel = "ext"}).
}
\details{
The estimated parameters are arranged as follows:
\itemize{
\item Model "2012" (S = 2 + number of traits):
\itemize{
 \item theta[i, 1:S] = c(middle, extreme, trait(s))
 \item beta[j, 1:3] = c(middle, extreme, trait) (which trait depends on \code{traitItem}!)
 }
\item Model "ext" (S = 3 + number of traits):
\itemize{
 \item theta[i, 1:S] = c(middle, extreme, acquiesence, trait(s))
 \item beta[j, 1:4] = c(middle, extreme, acquiesence, trait) (which trait depends on \code{traitItem}!)
 }
}
If more than a single trait is measured, theta has more columns accordingly
(e.g., theta[i,1:6]=c(mid, extr, acq, trait1,..., trait3))
}
\examples{
\dontrun{
N <- 20
J <- 10
betas <- cbind(rnorm(J, .5), rnorm(J, .5), rnorm(J, 1.5), rnorm(J, 0))
dat <- generate_irtree_ext(N = N, J = J, betas = betas, beta_ARS_extreme = .5)

# fit model
res1 <- fit_irtree(dat$X, revItem = dat$revItem, M = 200)
res2 <- summarize_irtree_fit(res1)
res3 <- tidyup_irtree_fit(res2)
names(res3)
res3$plot
}
}
