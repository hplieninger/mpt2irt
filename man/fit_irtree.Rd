% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fit_model.R
\name{fit_irtree}
\alias{fit_irtree}
\title{Fit an mpt2irt model}
\usage{
fit_irtree(X, revItem = NULL, traitItem = rep(1, ncol(X)), df = NULL,
  V = NULL, fitModel = c("ext", "2012", "pcm", "steps", "shift",
  "ext2"), model = NULL, fitMethod = c("stan", "jags"),
  outFormat = NULL, startSmall = FALSE, M = 1000, warmup = 1000,
  n.chains = 2, thin = 1, method = "parallel", add2varlist = NULL,
  cores = NULL, summarise = FALSE, N2 = 2, ...)
}
\arguments{
\item{X}{an N x J matrix of observed responses for categories 1...5 (use
\code{\link{mult_to_cat}} to transform a multinomial frequency matrix with 1s/0s to
responses from 1...5)}

\item{revItem}{vector of length J specifying reversed items (1=reversed,
0=regular)}

\item{traitItem}{vector of length J specifying the underlying traits (e.g.,
indexed from 1...5). Standard: only a single trait is measured by all
items. If the Big5 are measured, might be something like
c(1,1,1,2,2,2,...,5,5,5,5)}

\item{df}{degrees of freedom for wishart prior on covariance of traits
(default: number of processes + 1)}

\item{V}{prior for wishart distribution (default: diagonal matrix)}

\item{fitModel}{Character. Either \code{"2012"} (Boeckenholt Model without
acquiescence) or \code{"ext"} (Acquiescence Model). Details about all
implemented models are described in the section Models below.}

\item{model}{If \code{NULL} (the usual case), this is determined by
\code{fitModel}. Otherwise, this is passed to \code{\link[rstan]{sampling}}
(for Stan) or \code{\link[runjags]{run.jags}} (for JAGS).}

\item{fitMethod}{whether to use JAGS or Stan}

\item{outFormat}{either "mcmc.list" (can be analyzed with coda package) or
"stan" or "runjags"}

\item{startSmall}{Whether to use random starting values for beta sampled from
"wide" (FALSE) or "narrow" priors (TRUE; beta and theta
closer to 0; might solve problems with slow convergence of some chains for
extreme starting values).}

\item{M}{number of MCMC samples (after warmup)}

\item{warmup}{number of samples for warmup (in JAGS: 1/5 for adaptation, 4/5
for burnin)}

\item{n.chains}{number of MCMC chains (and number of CPUs used)}

\item{thin}{thinning of MCMC samples}

\item{method}{Passed to \code{\link[runjags]{run.jags}}. Can be, for example,
\code{parallel} or \code{simple}.}

\item{add2varlist}{Additional variables to monitor (e.g., \code{c("deviance",
"pd", "popt", "dic")} for JAGS)}

\item{cores}{Passed to \code{\link[rstan]{sampling}}: Number of cores to use
when executing the chains in parallel.}

\item{summarise}{Passed to \code{\link[runjags]{run.jags}}: Should summary
statistics be automatically calculated for the output chains? Defaults to
FALSE, summaries can be calculated using \code{\link{tidyup_irtree_fit}.}}

\item{N2}{Numeric. Number of persons for whom to draw posterior predictives.
Specify equal to \code{nrow(X)} in order to draw values for all persons.
This is mainly implemented for efficiency reasons in order to avoid
massivly drawing samples which the user is not interested in.}

\item{...}{further arguments passed to \code{\link[rstan]{sampling}} (for
Stan) or \code{\link[runjags]{run.jags}} (for JAGS)}
}
\value{
Returns a list where the output from either JAGS or Stan is stored in
  the entry \code{samples}.
}
\description{
This function fits an mpt2irt model. Either the so-called Boeckenholt Model
can be fit (\code{fitModel = "2012"}) that assumes the three processes MRS,
ERS, and target trait; or the so-called Acquiescence Model can be fit that
additionally takes ARS into account (\code{fitModel = "ext"}).
}
\details{
Note that DIC can only be saved using \code{fitMethod = "jags"} in
combination with \code{method = "simple"}. Furthermore, you need to
explicitly request DIC using, for example, \code{add2varlist = c("deviance",
"pd", "popt", "dic")}.
}
\section{Models}{


The following models are currently implemented:
\describe{
  \item{\code{2012}}{This is the response style model proposed by Boeckenholt
  (2012) with parameters m (MRS), e (ERS), and t (target trait).}
  \item{\code{ext}}{This is the Acquiescence Model proposed by Plieninger and Heck
  (2018) with parameters m (MRS), e (ERS), a (ARS), and t (target trait). The
  e* parameter is constrained, namely, all item parameters are constrained to
  be equal.}
  \item{\code{steps}}{This is an ordinal IRT model without response styles as
  proposed by Tutz (1990) and Verhelst et al. (1997). It is also based on a
  tree structure but has only the parameter t (target trait).}
  \item{\code{pcm}}{This is an ordinal IRT model without response styles,
  namely, the partial credit model, which has only the parameter t (target
  trait).}
  \item{\code{shift}}{This is the tree-shift model proposed by Plieninger and
  Heck (2018) in Appendix A with parameters m (MRS), e (ERS), and ta (target
  trait and ARS). For regular items, ta = t + a, whereas for reversed items,
  ta = -t + a. Unlike the Acquiescence Model (\code{ext}), this model is not
  a mixture model.}
  \item{\code{ext2}}{This is the unrestricted version of the Acquiescence
  Model. Therein, fewer constraints are imposed on the e* parameter, and all
  its item parameters are free to vary.}
}
}

\section{Note on Output}{


In the output, the estimated parameters are always arranged in the order MRS,
ERS, ARS, target trait(s). For example, a \code{2012}-model with two target
traits (specified via \code{traitItem}), has four person parameters and MRS
is the first, ERS the second, and the two target traits the third and fourth.

Furthermore, only one subscript and column is used for each type of item
parameter. That is, all \eqn{\beta_t} (i.e., target-trait difficulites) are stored
in one column and \code{traitItem} indicates which parameter pertains to
which target trait.

This is illustrated for two models in the following:
\itemize{
\item Model \code{2012} (S = 2 + number of traits):
\itemize{
 \item theta[i, 1:S] = c(MRS, ERS, target trait(s))
 \item beta[j, 1:3] = c(MRS, ERS, target trait)
 }
\item Model \code{ext} (S = 3 + number of traits):
\itemize{
 \item theta[i, 1:S] = c(MRS, ERS, ARS, target trait(s))
 \item beta[j, 1:4] = c(MRS, ERS, ARS, target trait)
 }
}
}

\examples{
\dontrun{
N <- 20
J <- 10
betas <- cbind(rnorm(J, .5), rnorm(J, .5), rnorm(J, 1.5), rnorm(J, 0))
dat <- generate_irtree_ext(N = N, J = J, betas = betas, beta_ARS_extreme = .5)

# fit model
res1 <- fit_irtree(dat$X, revItem = dat$revItem, M = 200)
res2 <- summarize_irtree_fit(res1)
res3 <- tidyup_irtree_fit(res2)
names(res3)
res3$plot
}
}
